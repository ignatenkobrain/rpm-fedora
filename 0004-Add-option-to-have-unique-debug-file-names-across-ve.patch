From 76e637c715e13fe7f746feb29af4a6fd0de3cbc7 Mon Sep 17 00:00:00 2001
Message-Id: <76e637c715e13fe7f746feb29af4a6fd0de3cbc7.1488964568.git.pmatilai@redhat.com>
In-Reply-To: <189b4f88c8e100155ec23a1e0b214bdc8473532a.1488964568.git.pmatilai@redhat.com>
References: <189b4f88c8e100155ec23a1e0b214bdc8473532a.1488964568.git.pmatilai@redhat.com>
From: Mark Wielaard <mjw@redhat.com>
Date: Thu, 16 Jun 2016 14:24:22 +0200
Subject: [PATCH 04/11] Add option to have unique debug file names across
 version/release/arch.

Introduce a new macro _unique_debug_names that when set will pass
--unique-debug-arch "%{_arch}" to find-debuginfo.sh to create debuginfo
files which end in "-<ver>-<rel>.<arch>.debug" instead of simply ".debug".

Adds testcases for dwz and buildid with and without unique debug file names.

Signed-off-by: Mark Wielaard <mjw@redhat.com>
---
 build/files.c             |  19 ++-
 macros.debug              |   3 +
 macros.in                 |   9 +-
 scripts/find-debuginfo.sh |  18 ++-
 tests/rpmbuild.at         | 168 +++++++++++++++++++-----
 tests/rpmbuildid.at       | 316 +++++++++++++++++++++++++++++++++++++++++++++-
 6 files changed, 494 insertions(+), 39 deletions(-)

diff --git a/build/files.c b/build/files.c
index b010483..eb39856 100644
--- a/build/files.c
+++ b/build/files.c
@@ -1790,6 +1790,16 @@ static int generateBuildIDs(FileList fl)
 	    }
 	}
 
+	/* In case we need ALLDEBUG links we might need the vra as
+	   tagged onto the .debug file name. */
+	char *vra = NULL;
+	if (rc == 0 && needDbg && build_id_links == BUILD_IDS_ALLDEBUG) {
+	    int unique_debug_names =
+		rpmExpandNumeric("%{?_unique_debug_names}");
+	    if (unique_debug_names == 1)
+		vra = rpmExpand("-%{version}-%{release}.%{_arch}", NULL);
+	}
+
 	/* Now add a subdir and symlink for each buildid found.  */
 	for (i = 0; i < nr_ids; i++) {
 	    /* Don't add anything more when an error occured. But do
@@ -1884,15 +1894,17 @@ static int generateBuildIDs(FileList fl)
 			    int pathlen = strlen(paths[i]);
 			    int debuglen = strlen(".debug");
 			    int prefixlen = strlen("/usr/lib/debug");
-			    if (pathlen > prefixlen
-				&& strcmp (paths[i] + pathlen - debuglen,
+			    int vralen = vra == NULL ? 0 : strlen(vra);
+			    if (pathlen > prefixlen + debuglen + vralen
+				&& strcmp ((paths[i] + pathlen - debuglen),
 					   ".debug") == 0) {
 				free(linkpath);
 				free(targetpath);
 				char *targetstr = xstrdup (paths[i]
 							   + prefixlen);
 				int targetlen = pathlen - prefixlen;
-				targetstr[targetlen - debuglen] = '\0';
+				int targetend = targetlen - debuglen - vralen;
+				targetstr[targetend] = '\0';
 				rasprintf(&linkpath, "%s/%s",
 					  buildidsubdir, &ids[i][2]);
 				rasprintf(&targetpath, "../../../../..%s",
@@ -1911,6 +1923,7 @@ static int generateBuildIDs(FileList fl)
 	    free(paths[i]);
 	    free(ids[i]);
 	}
+	free(vra);
 	free(paths);
 	free(ids);
     }
diff --git a/macros.debug b/macros.debug
index d273c08..ee0cc9e 100644
--- a/macros.debug
+++ b/macros.debug
@@ -1,4 +1,7 @@
 # macros to include to generate debuginfo
+# Note don't define/enable a feature here if it is already the default in
+# macros.in. Otherwise it cannot simply be --undefined on the command line
+# in the tests (it needs to be undefined multiple times then).
 
 %_enable_debug_packages 1
 %_include_minidebuginfo 1
diff --git a/macros.in b/macros.in
index c845f58..68bf391 100644
--- a/macros.in
+++ b/macros.in
@@ -180,7 +180,7 @@
 #	the script.  See the script for details.
 #
 %__debug_install_post   \
-   %{_rpmconfigdir}/find-debuginfo.sh %{?_missing_build_ids_terminate_build:--strict-build-id} %{?_include_minidebuginfo:-m} %{?_include_gdb_index:-i} %{?_unique_build_ids:--ver-rel "%{version}-%{release}"} %{?_find_debuginfo_dwz_opts} %{?_find_debuginfo_opts} "%{_builddir}/%{?buildsubdir}"\
+   %{_rpmconfigdir}/find-debuginfo.sh %{?_missing_build_ids_terminate_build:--strict-build-id} %{?_include_minidebuginfo:-m} %{?_include_gdb_index:-i} %{?_unique_build_ids:--ver-rel "%{version}-%{release}"} %{?_unique_debug_names:--unique-debug-arch "%{_arch}"} %{?_find_debuginfo_dwz_opts} %{?_find_debuginfo_opts} "%{_builddir}/%{?buildsubdir}"\
 %{nil}
 
 #	Template for debug information sub-package.
@@ -488,6 +488,13 @@ package or when debugging this package.\
 # onto debugedit --build-id-seed to be used to prime the build-id note hash.
 %_unique_build_ids	1
 
+# Whether .debug files should be made unique between package version,
+# release and architecture. If set to 1 this will pass
+# --unique-debug-arch "%{_arch}" to find-debuginfo.sh to create
+# debuginfo files which end in -<ver>-<rel>.<arch>.debug
+# Requires _unique_build_ids.
+%_unique_debug_names	1
+
 #
 # Use internal dependency generator rather than external helpers?
 %_use_internal_dependency_generator	1
diff --git a/scripts/find-debuginfo.sh b/scripts/find-debuginfo.sh
index 8e60813..3653c48 100644
--- a/scripts/find-debuginfo.sh
+++ b/scripts/find-debuginfo.sh
@@ -64,6 +64,9 @@ dwz_max_die_limit=
 # Version and release of the spec. Given by --ver-rel
 ver_rel=
 
+# Arch given by --unique-debug-arch
+unique_debug_arch=
+
 BUILDDIR=.
 out=debugfiles.list
 nout=0
@@ -87,6 +90,10 @@ while [ $# -gt 0 ]; do
     ver_rel=$2
     shift
     ;;
+  --unique-debug-arch)
+    unique_debug_arch=$2
+    shift
+    ;;
   -g)
     strip_g=true
     ;;
@@ -125,6 +132,11 @@ while [ $# -gt 0 ]; do
   shift
 done
 
+if test -z "$ver_rel" -a -n "$unique_debug_arch"; then
+  echo >&2 "*** ERROR: --unique-debug-arch (${unique_debug_arch}) needs --ver-rel (${ver_rel})"
+  exit 2
+fi
+
 i=0
 while ((i < nout)); do
   outs[$i]="$BUILDDIR/${outs[$i]}"
@@ -232,7 +244,11 @@ debug_link()
 get_debugfn()
 {
   dn=$(dirname "${1#$RPM_BUILD_ROOT}")
-  bn=$(basename "$1" .debug).debug
+  if test -n "${unique_debug_arch}"; then
+    bn=$(basename "$1" .debug)-${ver_rel}.${unique_debug_arch}.debug
+  else
+    bn=$(basename "$1" .debug).debug
+  fi
 
   debugdn=${debugdir}${dn}
   debugfn=${debugdn}/${bn}
diff --git a/tests/rpmbuild.at b/tests/rpmbuild.at
index a312324..0a2c01e 100644
--- a/tests/rpmbuild.at
+++ b/tests/rpmbuild.at
@@ -386,8 +386,9 @@ AT_CLEANUP
 # Check if rpmbuild runs dwz and generates a multi file that with shared
 # debuginfo. This is simply the hello example with one binary build twice
 # so dwz has enough slightly similar debug data.
+# Test the case without unique debug file names.
 AT_SETUP([rpmbuild debuginfo dwz])
-AT_KEYWORDS([build] [debuginfo])
+AT_KEYWORDS([build] [debuginfo] [dwz])
 AT_CHECK([
 rm -rf ${TOPDIR}
 AS_MKDIR_P(${TOPDIR}/SOURCES)
@@ -397,63 +398,170 @@ cp "${abs_srcdir}"/data/SOURCES/hello-1.0.tar.gz "${abs_srcdir}"/data/SOURCES/he
 run rpmbuild --quiet \
   --macros=${abs_top_builddir}/macros:${abs_top_builddir}/tests/testing/usr/local/lib/rpm/platform/%{_target_cpu}-%{_target_os}/macros:${top_srcdir}/macros.debug \
   --rcfile=${abs_top_builddir}/rpmrc \
+  --undefine "_unique_debug_names" \
   -ba "${abs_srcdir}"/data/SPECS/hello2.spec
 
 # The debuginfo package should contain a .debug file for each binary
 # and a dwz multi file that contains the shared debuginfo between them.
 rpm2cpio ${abs_builddir}/testing/build/RPMS/*/hello2-debuginfo-1.0-1.*.rpm \
   | cpio -diu
-test -f ./usr/lib/debug/usr/local/bin/hello.debug || exit 1
-test -f ./usr/lib/debug/usr/local/bin/hello2.debug || exit 1
-test -f ./usr/lib/debug/.dwz/hello2-1.0-1.* || exit 1
+
+hello_file_debug=./usr/lib/debug/usr/local/bin/hello.debug
+hello2_file_debug=./usr/lib/debug/usr/local/bin/hello2.debug
+hello_multi_file=./usr/lib/debug/.dwz/hello2-1.0-1.*
+test -f $hello_file_debug || echo "no hello debug file: $hello_file_debug"
+test -f $hello2_file_debug || echo "no hello2 debug file: $hello2_file_debug"
+test -f $hello_multi_file || echo "no dwz multi file: $hello_multi_file"
 
 # Make sure the main package binaries contain the correct build-ids
 # linking them to the debug packages.
 rpm2cpio ${abs_builddir}/testing/build/RPMS/*/hello2-1.0-1.*.rpm \
   | cpio -diu
-id1=$(file ./usr/local/bin/hello | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
-id2=$(file ./usr/local/bin/hello2 | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
-id1debug=$(file ./usr/lib/debug/usr/local/bin/hello.debug \
-  | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
-id2debug=$(file ./usr/lib/debug/usr/local/bin/hello2.debug \
-  | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
-idmulti=$(file ./usr/lib/debug/.dwz/hello2-1.0-1.* \
-  | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
-
-test "$id1" = "$id1debug" || exit 1
-test "$id2" = "$id2debug" || exit 1
+hello_file=./usr/local/bin/hello
+hello2_file=./usr/local/bin/hello2
+test -f $hello_file || echo "no hello file: $hello_file"
+test -f $hello2_file || echo "no hello2 file: $hello2_file"
+
+id1=$(file $hello_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+id2=$(file $hello2_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+id1debug=$(file $hello_file_debug | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+id2debug=$(file $hello2_file_debug | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+idmulti=$(file $hello_multi_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+
+test "$id1" = "$id1debug" || echo "id1: $id1 != id1debug: $id1debug"
+test "$id2" = "$id2debug" || echo "id2: $id2 != id2debug: $id2debug"
+
+# The build-id files should link to the .debug files.
+id1file="./usr/lib/debug/.build-id/${id1:0:2}/${id1:2}"
+canonid1file=$(readlink -f ${id1file})
+canonfile1=$(readlink -f $hello_file)
+canonid1debug=$(readlink -f ${id1file}.debug)
+canondebug1=$(readlink -f $hello_file_debug)
+
+test "$canonid1file" = "$canonfile1" \
+  || echo "canonid1file: $canonid1file != $canonfile1"
+test "$canonid1debug" = "$canondebug1" \
+  || echo "canonid1debug: $canonid1debug != $canondebug1"
+
+id2file="./usr/lib/debug/.build-id/${id2:0:2}/${id2:2}"
+canonid2file=$(readlink -f ${id2file})
+canonfile2=$(readlink -f $hello2_file)
+canonid2debug=$(readlink -f ${id2file}.debug)
+canondebug2=$(readlink -f $hello2_file_debug)
+
+test "$canonid2file" = "$canonfile2" \
+  || echo "canonid2: $canonid2file != $canonfile2"
+test "$canonid2debug" = "$canondebug2" \
+  || echo "canonid2debug: $canonid2debug" != "$canondebug2"
+
+# Both .debug files should point to the dwz multi file.
+# It would be nice to also test that they contain the correct dwz build-id
+# but that is a bit hard to grep out of the section data.
+multiref1=$(readelf --string-dump=.gnu_debugaltlink $hello_file_debug \
+  | grep '[     0]' | cut -c13-)
+multiref2=$(readelf --string-dump=.gnu_debugaltlink $hello2_file_debug \
+  | grep '[     0]' | cut -c13-)
+
+test "$multiref1" = "$multiref2" || echo "multiref: $multiref1 != $multiref2"
+
+canonmultiref=$(readlink -f $(dirname $canondebug1)/$multiref1)
+canonmultifile=$(readlink -f $hello_multi_file)
+
+test "$canonmultiref" = "$canonmultifile" \
+  || echo "canonmultiref: $canonmultiref" != "$canonmultifile"
+],
+[0],
+[],
+[ignore])
+AT_CLEANUP
+
+# ------------------------------
+# Check if rpmbuild runs dwz and generates a multi file that with shared
+# debuginfo. This is simply the hello example with one binary build twice
+# so dwz has enough slightly similar debug data.
+# Test with unique debug file names.
+AT_SETUP([rpmbuild debuginfo dwz unique debug names])
+AT_KEYWORDS([build] [debuginfo] [dwz])
+AT_CHECK([
+rm -rf ${TOPDIR}
+AS_MKDIR_P(${TOPDIR}/SOURCES)
+
+cp "${abs_srcdir}"/data/SOURCES/hello-1.0.tar.gz "${abs_srcdir}"/data/SOURCES/hello-1.0-modernize.patch ${TOPDIR}/SOURCES
+
+run rpmbuild --quiet \
+  --macros=${abs_top_builddir}/macros:${abs_top_builddir}/tests/testing/usr/local/lib/rpm/platform/%{_target_cpu}-%{_target_os}/macros:${top_srcdir}/macros.debug \
+  --rcfile=${abs_top_builddir}/rpmrc \
+  --define "_unique_debug_names 1" \
+  -ba "${abs_srcdir}"/data/SPECS/hello2.spec
+
+# The debuginfo package should contain a .debug file for each binary
+# and a dwz multi file that contains the shared debuginfo between them.
+rpm2cpio ${abs_builddir}/testing/build/RPMS/*/hello2-debuginfo-1.0-1.*.rpm \
+  | cpio -diu
+
+hello_file_debug=./usr/lib/debug/usr/local/bin/hello-*.debug
+hello2_file_debug=./usr/lib/debug/usr/local/bin/hello2-*.debug
+hello_multi_file=./usr/lib/debug/.dwz/hello2-1.0-1.*
+test -f $hello_file_debug || echo "no hello debug file: $hello_file_debug"
+test -f $hello2_file_debug || echo "no hello2 debug file: $hello2_file_debug"
+test -f $hello_multi_file || echo "no dwz multi file: $hello_multi_file"
+
+# Make sure the main package binaries contain the correct build-ids
+# linking them to the debug packages.
+rpm2cpio ${abs_builddir}/testing/build/RPMS/*/hello2-1.0-1.*.rpm \
+  | cpio -diu
+hello_file=./usr/local/bin/hello
+hello2_file=./usr/local/bin/hello2
+test -f $hello_file || echo "no hello file: $hello_file"
+test -f $hello2_file || echo "no hello2 file: $hello2_file"
+
+id1=$(file $hello_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+id2=$(file $hello2_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+id1debug=$(file $hello_file_debug | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+id2debug=$(file $hello2_file_debug | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+idmulti=$(file $hello_multi_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+
+test "$id1" = "$id1debug" || echo "id1: $id1 != id1debug: $id1debug"
+test "$id2" = "$id2debug" || echo "id2: $id2 != id2debug: $id2debug"
 
 # The build-id files should link to the .debug files.
 id1file="./usr/lib/debug/.build-id/${id1:0:2}/${id1:2}"
 canonid1file=$(readlink -f ${id1file})
-canonfile1=$(readlink -f ./usr/local/bin/hello)
+canonfile1=$(readlink -f $hello_file)
 canonid1debug=$(readlink -f ${id1file}.debug)
-canondebug1=$(readlink -f ./usr/lib/debug/usr/local/bin/hello.debug)
+canondebug1=$(readlink -f $hello_file_debug)
 
-test "$canonid1file" = "$canonfile1" || exit 1
-test "$canonid1debug" = "$canondebug1" || exit 1
+test "$canonid1file" = "$canonfile1" \
+  || echo "canonid1file: $canonid1file != $canonfile1"
+test "$canonid1debug" = "$canondebug1" \
+  || echo "canonid1debug: $canonid1debug != $canondebug1"
 
 id2file="./usr/lib/debug/.build-id/${id2:0:2}/${id2:2}"
-canonid2file=$(readlink -f ${id1file})
-canonfile2=$(readlink -f ./usr/local/bin/hello)
-canonid2debug=$(readlink -f ${id1file}.debug)
-canondebug2=$(readlink -f ./usr/lib/debug/usr/local/bin/hello.debug)
+canonid2file=$(readlink -f ${id2file})
+canonfile2=$(readlink -f $hello2_file)
+canonid2debug=$(readlink -f ${id2file}.debug)
+canondebug2=$(readlink -f $hello2_file_debug)
 
-test "$canonid2file" = "$canonfile2" || exit 1
-test "$canonid2debug" = "$canondebug2" || exit 1
+test "$canonid2file" = "$canonfile2" \
+  || echo "canonid2: $canonid2file != $canonfile2"
+test "$canonid2debug" = "$canondebug2" \
+  || echo "canonid2debug: $canonid2debug" != "$canondebug2"
 
 # Both .debug files should point to the dwz multi file.
 # It would be nice to also test that they contain the correct dwz build-id
 # but that is a bit hard to grep out of the section data.
-multiref1=$(readelf --string-dump=.gnu_debugaltlink ./usr/lib/debug/usr/local/bin/hello.debug | grep '[     0]' | cut -c13-)
-multiref2=$(readelf --string-dump=.gnu_debugaltlink ./usr/lib/debug/usr/local/bin/hello2.debug | grep '[     0]' | cut -c13-)
+multiref1=$(readelf --string-dump=.gnu_debugaltlink $hello_file_debug \
+  | grep '[     0]' | cut -c13-)
+multiref2=$(readelf --string-dump=.gnu_debugaltlink $hello2_file_debug \
+  | grep '[     0]' | cut -c13-)
 
-test "$multiref1" = "$multiref2" || exit 1
+test "$multiref1" = "$multiref2" || echo "multiref: $multiref1 != $multiref2"
 
 canonmultiref=$(readlink -f $(dirname $canondebug1)/$multiref1)
-canonmultifile=$(readlink -f ./usr/lib/debug/.dwz/hello2-1.0-1.*)
+canonmultifile=$(readlink -f $hello_multi_file)
 
-test "$canonmultiref" = "$canonmultifile" || exit 1
+test "$canonmultiref" = "$canonmultifile" \
+  || echo "canonmultiref: $canonmultiref" != "$canonmultifile"
 ],
 [0],
 [],
diff --git a/tests/rpmbuildid.at b/tests/rpmbuildid.at
index 1da6302..ede1181 100644
--- a/tests/rpmbuildid.at
+++ b/tests/rpmbuildid.at
@@ -54,7 +54,8 @@ hello debuginfo build-id files: 0
 AT_CLEANUP
 
 # ------------------------------
-# Check if rpmbuild "alldebug" generates debuginfo buildid symlinks
+# Check if rpmbuild "alldebug" generates debuginfo buildid symlinks.
+# Without unique debug file names.
 AT_SETUP([rpmbuild buildid alldebug])
 AT_KEYWORDS([build] [debuginfo] [buildid])
 AT_CHECK([
@@ -69,6 +70,7 @@ run rpmbuild \
   --macros=${abs_top_builddir}/macros:${abs_top_builddir}/tests/testing/usr/local/lib/rpm/platform/%{_target_cpu}-%{_target_os}/macros:${top_srcdir}/macros.debug \
   --rcfile=${abs_top_builddir}/rpmrc \
   --define="_build_id_links alldebug" \
+  --undefine "_unique_debug_names" \
   --quiet -ba "${abs_srcdir}"/data/SPECS/hello.spec
 
 # There should be zero build-id files in the main package
@@ -114,7 +116,100 @@ test "$canon_main_file" = "$canon_main_id_file" \
 
 # And check the same for the debug file.
 debug_file=./usr/lib/debug/usr/local/bin/hello.debug
-test -f "${debug_file}" || echo "No debug file ${debug_file}"
+test -f ${debug_file} || echo "No debug file ${debug_file}"
+
+# Extract the build-id from the .debug file
+id_debug=$(file $debug_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+
+test ${id_main} = ${id_debug} || echo "unequal main and debug id"
+
+id_debug_file="./usr/lib/debug/.build-id/${id_debug:0:2}/${id_debug:2}.debug"
+test -L "$id_debug_file" || echo "No build-id file $id_debug_file"
+
+canon_debug_file=$(readlink -f ${debug_file})
+
+test -f "$canon_debug_file" \
+  || echo "Cannot resolve debug file ${debug_file} -> ${canon_debug_file}"
+
+canon_debug_id_file=$(readlink -f ${id_debug_file})
+
+test -f "$canon_debug_id_file" \
+  || echo "Cannot resolve debug build-id file ${id_debug_file} -> ${canon_debug_id_file}"
+
+test "$canon_debug_file" = "$canon_debug_id_file" \
+  || echo "debug and build-id not linked"
+],
+[0],
+[hello build-id files: 0
+hello debuginfo build-id files: 3
+],
+[ignore])
+AT_CLEANUP
+
+# ------------------------------
+# Check if rpmbuild "alldebug" generates debuginfo buildid symlinks.
+# With unique debug file names.
+AT_SETUP([rpmbuild buildid alldebug unique debug names])
+AT_KEYWORDS([build] [debuginfo] [buildid])
+AT_CHECK([
+rm -rf ${TOPDIR}
+AS_MKDIR_P(${TOPDIR}/SOURCES)
+
+# Setup sources
+cp "${abs_srcdir}"/data/SOURCES/hello-1.0.tar.gz "${abs_srcdir}"/data/SOURCES/hello-1.0-modernize.patch ${TOPDIR}/SOURCES
+
+# Build, contains one ELF which should have a buildid.
+run rpmbuild \
+  --macros=${abs_top_builddir}/macros:${abs_top_builddir}/tests/testing/usr/local/lib/rpm/platform/%{_target_cpu}-%{_target_os}/macros:${top_srcdir}/macros.debug \
+  --rcfile=${abs_top_builddir}/rpmrc \
+  --define="_build_id_links alldebug" \
+  --define="_unique_debug_names 1" \
+  --quiet -ba "${abs_srcdir}"/data/SPECS/hello.spec
+
+# There should be zero build-id files in the main package
+# Main and debug should be in the debuginfo package,
+# plus the .build-id/xx subdir, 3 in total.
+echo -n "hello build-id files: "
+run rpm -ql -p "${TOPDIR}"/RPMS/*/hello-1.0-1.*.rpm \
+  | grep /.build-id/ | wc --lines
+
+echo -n "hello debuginfo build-id files: "
+run rpm -ql -p "${TOPDIR}"/RPMS/*/hello-debuginfo-1.0-1.*.rpm \
+  | grep /.build-id/ | wc --lines
+
+# Extract the both packages to check the build-id files link to the
+# main and .debug files.
+rpm2cpio ${abs_builddir}/testing/build/RPMS/*/hello-1.0-1.*.rpm \
+  | cpio -diu
+rpm2cpio ${abs_builddir}/testing/build/RPMS/*/hello-debuginfo-1.0-1.*.rpm \
+  | cpio -diu
+
+# Check there is a build-id symlink for the main file.
+main_file=./usr/local/bin/hello
+test -f "${main_file}" || echo "No main file ${main_file}"
+
+# Extract the build-id from the main file
+id_main=$(file $main_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+
+id_main_file="./usr/lib/debug/.build-id/${id_main:0:2}/${id_main:2}"
+test -L "$id_main_file" || echo "No build-id file $id_main_file"
+
+canon_main_file=$(readlink -f ${main_file})
+
+test -f "$canon_main_file" \
+  || echo "Cannot resolve main file ${main_file} -> ${canon_main_file}"
+
+canon_main_id_file=$(readlink -f ${id_main_file})
+
+test -f "$canon_main_id_file" \
+  || echo "Cannot resolve main build-id file ${id_main_file} -> ${canon_main_id_file}"
+
+test "$canon_main_file" = "$canon_main_id_file" \
+  || echo "main and build-id file not linked"
+
+# And check the same for the debug file.
+debug_file=./usr/lib/debug/usr/local/bin/hello-*.debug
+test -f ${debug_file} || echo "No debug file ${debug_file}"
 
 # Extract the build-id from the .debug file
 id_debug=$(file $debug_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
@@ -146,6 +241,7 @@ AT_CLEANUP
 
 # ------------------------------
 # Check if rpmbuild "separate" generates main and debuginfo buildid symlinks
+# Without unique debug file names
 AT_SETUP([rpmbuild buildid separate])
 AT_KEYWORDS([build] [debuginfo] [buildid])
 AT_CHECK([
@@ -160,6 +256,7 @@ run rpmbuild \
   --macros=${abs_top_builddir}/macros:${abs_top_builddir}/tests/testing/usr/local/lib/rpm/platform/%{_target_cpu}-%{_target_os}/macros:${top_srcdir}/macros.debug \
   --rcfile=${abs_top_builddir}/rpmrc \
   --define="_build_id_links separate" \
+  --undefine "_unique_debug_names" \
   --quiet -ba "${abs_srcdir}"/data/SPECS/hello.spec
 
 # There should be one build-id files in the main and debuginfo package
@@ -204,7 +301,99 @@ test "$canon_main_file" = "$canon_main_id_file" \
 
 # And check the same for the debug file.
 debug_file=./usr/lib/debug/usr/local/bin/hello.debug
-test -f "${debug_file}" || echo "No debug file ${debug_file}"
+test -f ${debug_file} || echo "No debug file ${debug_file}"
+
+# Extract the build-id from the .debug file
+id_debug=$(file $debug_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+
+test ${id_main} = ${id_debug} || echo "unequal main and debug id"
+
+id_debug_file="./usr/lib/debug/.build-id/${id_debug:0:2}/${id_debug:2}.debug"
+test -L "$id_debug_file" || echo "No build-id file $id_debug_file"
+
+canon_debug_file=$(readlink -f ${debug_file})
+
+test -f "$canon_debug_file" \
+  || echo "Cannot resolve debug file ${debug_file} -> ${canon_debug_file}"
+
+canon_debug_id_file=$(readlink -f ${id_debug_file})
+
+test -f "$canon_debug_id_file" \
+  || echo "Cannot resolve debug build-id file ${id_debug_file} -> ${canon_debug_id_file}"
+
+test "$canon_debug_file" = "$canon_debug_id_file" \
+  || echo "debug and build-id not linked"
+],
+[0],
+[hello build-id files: 2
+hello debuginfo build-id files: 2
+],
+[ignore])
+AT_CLEANUP
+
+# ------------------------------
+# Check if rpmbuild "separate" generates main and debuginfo buildid symlinks
+# With unique debug file names
+AT_SETUP([rpmbuild buildid separate unique debug names])
+AT_KEYWORDS([build] [debuginfo] [buildid])
+AT_CHECK([
+rm -rf ${TOPDIR}
+AS_MKDIR_P(${TOPDIR}/SOURCES)
+
+# Setup sources
+cp "${abs_srcdir}"/data/SOURCES/hello-1.0.tar.gz "${abs_srcdir}"/data/SOURCES/hello-1.0-modernize.patch ${TOPDIR}/SOURCES
+
+# Build, contains one ELF which should have a buildid.
+run rpmbuild \
+  --macros=${abs_top_builddir}/macros:${abs_top_builddir}/tests/testing/usr/local/lib/rpm/platform/%{_target_cpu}-%{_target_os}/macros:${top_srcdir}/macros.debug \
+  --rcfile=${abs_top_builddir}/rpmrc \
+  --define="_build_id_links separate" \
+  --define="_unique_debug_names 1" \
+  --quiet -ba "${abs_srcdir}"/data/SPECS/hello.spec
+
+# There should be one build-id files in the main and debuginfo package
+# plus the .build-id/xx subdir, 2 in total.
+echo -n "hello build-id files: "
+run rpm -ql -p "${TOPDIR}"/RPMS/*/hello-1.0-1.*.rpm \
+  | grep /.build-id/ | wc --lines
+
+echo -n "hello debuginfo build-id files: "
+run rpm -ql -p "${TOPDIR}"/RPMS/*/hello-debuginfo-1.0-1.*.rpm \
+  | grep /.build-id/ | wc --lines
+
+# Extract the both packages to check the build-id files link to the
+# main and .debug files.
+rpm2cpio ${abs_builddir}/testing/build/RPMS/*/hello-1.0-1.*.rpm \
+  | cpio -diu
+rpm2cpio ${abs_builddir}/testing/build/RPMS/*/hello-debuginfo-1.0-1.*.rpm \
+  | cpio -diu
+
+# Check there is a build-id symlink for the main file.
+main_file=./usr/local/bin/hello
+test -f "${main_file}" || echo "No main file ${main_file}"
+
+# Extract the build-id from the main file
+id_main=$(file $main_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+
+id_main_file="./usr/lib/.build-id/${id_main:0:2}/${id_main:2}"
+test -L "$id_main_file" || echo "No build-id file $id_main_file"
+
+canon_main_file=$(readlink -f ${main_file})
+
+test -f "$canon_main_file" \
+  || echo "Cannot resolve main file ${main_file} -> ${canon_main_file}"
+
+canon_main_id_file=$(readlink -f ${id_main_file})
+
+test -f "$canon_main_id_file" \
+  || echo "Cannot resolve main build-id file ${id_main_file} -> ${canon_main_id_file}"
+
+test "$canon_main_file" = "$canon_main_id_file" \
+  || echo "main and build-id file not linked"
+
+# And check the same for the debug file.
+debug_file=./usr/lib/debug/usr/local/bin/hello-*.debug
+test -f ${debug_file} || echo "No debug file ${debug_file}"
 
 # Extract the build-id from the .debug file
 id_debug=$(file $debug_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
@@ -236,6 +425,7 @@ AT_CLEANUP
 
 # ------------------------------
 # Check if rpmbuild "compat" generates main and debuginfo buildid symlinks
+# Without unique debug file names
 AT_SETUP([rpmbuild buildid compat])
 AT_KEYWORDS([build] [debuginfo] [buildid])
 AT_CHECK([
@@ -250,6 +440,7 @@ run rpmbuild \
   --macros=${abs_top_builddir}/macros:${abs_top_builddir}/tests/testing/usr/local/lib/rpm/platform/%{_target_cpu}-%{_target_os}/macros:${top_srcdir}/macros.debug \
   --rcfile=${abs_top_builddir}/rpmrc \
   --define="_build_id_links compat" \
+  --undefine "_unique_debug_names" \
   --quiet -ba "${abs_srcdir}"/data/SPECS/hello.spec
 
 # There should be one build-id files in the main and debuginfo package.
@@ -295,7 +486,112 @@ test "$canon_main_file" = "$canon_main_id_file" \
 
 # And check the same for the debug file.
 debug_file=./usr/lib/debug/usr/local/bin/hello.debug
-test -f "${debug_file}" || echo "No debug file ${debug_file}"
+test -f ${debug_file} || echo "No debug file ${debug_file}"
+
+# Extract the build-id from the .debug file
+id_debug=$(file $debug_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+
+test ${id_main} = ${id_debug} || echo "unequal main and debug id"
+
+id_debug_file="./usr/lib/debug/.build-id/${id_debug:0:2}/${id_debug:2}.debug"
+test -L "$id_debug_file" || echo "No build-id file $id_debug_file"
+
+canon_debug_file=$(readlink -f ${debug_file})
+
+test -f "$canon_debug_file" \
+  || echo "Cannot resolve debug file ${debug_file} -> ${canon_debug_file}"
+
+canon_debug_id_file=$(readlink -f ${id_debug_file})
+
+test -f "$canon_debug_id_file" \
+  || echo "Cannot resolve debug build-id file ${id_debug_file} -> ${canon_debug_id_file}"
+
+test "$canon_debug_file" = "$canon_debug_id_file" \
+  || echo "debug and build-id not linked"
+
+# The compat link should also point to the same (indirectly).
+id_compat_file="./usr/lib/debug/.build-id/${id_main:0:2}/${id_main:2}"
+test -L "$id_compat_file" || echo "No build-id compat file $id_compat_file"
+
+canon_compat_file=$(readlink -f ${id_compat_file})
+
+test -f "$canon_compat_file" \
+  || echo "Cannot resolve compat file ${id_compat_file} -> ${canon_compat_file}"
+
+test "$canon_compat_file" = "$canon_main_file" \
+  || echo "compat and build-id not linked"
+],
+[0],
+[hello build-id files: 2
+hello debuginfo build-id files: 3
+],
+[ignore])
+AT_CLEANUP
+
+# ------------------------------
+# Check if rpmbuild "compat" generates main and debuginfo buildid symlinks
+# With unique debug file names
+AT_SETUP([rpmbuild buildid compat unique debug names])
+AT_KEYWORDS([build] [debuginfo] [buildid])
+AT_CHECK([
+rm -rf ${TOPDIR}
+AS_MKDIR_P(${TOPDIR}/SOURCES)
+
+# Setup sources
+cp "${abs_srcdir}"/data/SOURCES/hello-1.0.tar.gz "${abs_srcdir}"/data/SOURCES/hello-1.0-modernize.patch ${TOPDIR}/SOURCES
+
+# Build, contains one ELF which should have a buildid.
+run rpmbuild \
+  --macros=${abs_top_builddir}/macros:${abs_top_builddir}/tests/testing/usr/local/lib/rpm/platform/%{_target_cpu}-%{_target_os}/macros:${top_srcdir}/macros.debug \
+  --rcfile=${abs_top_builddir}/rpmrc \
+  --define="_build_id_links compat" \
+  --define="_unique_debug_names 1" \
+  --quiet -ba "${abs_srcdir}"/data/SPECS/hello.spec
+
+# There should be one build-id files in the main and debuginfo package.
+# the debuginfo package has one extra main build-id compat symlink
+# plus the .build-id/xx subdir, 2 in total in main, 3 in total in debug
+echo -n "hello build-id files: "
+run rpm -ql -p "${TOPDIR}"/RPMS/*/hello-1.0-1.*.rpm \
+  | grep /.build-id/ | wc --lines
+
+echo -n "hello debuginfo build-id files: "
+run rpm -ql -p "${TOPDIR}"/RPMS/*/hello-debuginfo-1.0-1.*.rpm \
+  | grep /.build-id/ | wc --lines
+
+# Extract the both packages to check the build-id files link to the
+# main and .debug files.
+rpm2cpio ${abs_builddir}/testing/build/RPMS/*/hello-1.0-1.*.rpm \
+  | cpio -diu
+rpm2cpio ${abs_builddir}/testing/build/RPMS/*/hello-debuginfo-1.0-1.*.rpm \
+  | cpio -diu
+
+# Check there is a build-id symlink for the main file.
+main_file=./usr/local/bin/hello
+test -f "${main_file}" || echo "No main file ${main_file}"
+
+# Extract the build-id from the main file
+id_main=$(file $main_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
+
+id_main_file="./usr/lib/.build-id/${id_main:0:2}/${id_main:2}"
+test -L "$id_main_file" || echo "No build-id file $id_main_file"
+
+canon_main_file=$(readlink -f ${main_file})
+
+test -f "$canon_main_file" \
+  || echo "Cannot resolve main file ${main_file} -> ${canon_main_file}"
+
+canon_main_id_file=$(readlink -f ${id_main_file})
+
+test -f "$canon_main_id_file" \
+  || echo "Cannot resolve main build-id file ${id_main_file} -> ${canon_main_id_file}"
+
+test "$canon_main_file" = "$canon_main_id_file" \
+  || echo "main and build-id file not linked"
+
+# And check the same for the debug file.
+debug_file=./usr/lib/debug/usr/local/bin/hello-*debug
+test -f ${debug_file} || echo "No debug file ${debug_file}"
 
 # Extract the build-id from the .debug file
 id_debug=$(file $debug_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
@@ -784,8 +1080,12 @@ rpm2cpio ${abs_builddir}/testing/build/RPMS/*/hello-1.0-1.*.rpm \
 hello_file=./usr/local/bin/hello
 
 # Extract the build-id from the main file
+test -f $hello_file || echo "No $hello_file"
 id1=$(file $hello_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
 
+# Make sure we generate a new one
+rm $hello_file
+
 # Build the "next" release, which has no changes except for the release update.
 run rpmbuild --quiet \
   --macros=${abs_top_builddir}/macros:${abs_top_builddir}/tests/testing/usr/local/lib/rpm/platform/%{_target_cpu}-%{_target_os}/macros:${top_srcdir}/macros.debug \
@@ -797,6 +1097,7 @@ rpm2cpio ${abs_builddir}/testing/build/RPMS/*/hello-1.0-2.*.rpm \
   | cpio -diu --quiet
 
 # Extract the build-id from the main file
+test -f $hello_file || echo "No $hello_file"
 id2=$(file $hello_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
 
 if test "$id1" == "$id2"; then echo "equal $id1"; else echo "unequal"; fi
@@ -823,6 +1124,7 @@ run rpmbuild --quiet \
   --macros=${abs_top_builddir}/macros:${abs_top_builddir}/tests/testing/usr/local/lib/rpm/platform/%{_target_cpu}-%{_target_os}/macros:${top_srcdir}/macros.debug \
   --rcfile=${abs_top_builddir}/rpmrc \
   --undefine="_unique_build_ids" \
+  --undefine="_unique_debug_names" \
   -ba "${abs_srcdir}"/data/SPECS/hello.spec
 
 rpm2cpio ${abs_builddir}/testing/build/RPMS/*/hello-1.0-1.*.rpm \
@@ -831,19 +1133,25 @@ rpm2cpio ${abs_builddir}/testing/build/RPMS/*/hello-1.0-1.*.rpm \
 hello_file=./usr/local/bin/hello
 
 # Extract the build-id from the main file
+test -f $hello_file || echo "No $hello_file"
 id1=$(file $hello_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
 
+# Make sure we generate a new one
+rm $hello_file
+
 # Build the "next" release, which has no changes except for the release update.
 run rpmbuild --quiet \
   --macros=${abs_top_builddir}/macros:${abs_top_builddir}/tests/testing/usr/local/lib/rpm/platform/%{_target_cpu}-%{_target_os}/macros:${top_srcdir}/macros.debug \
   --rcfile=${abs_top_builddir}/rpmrc \
   --undefine="_unique_build_ids" \
+  --undefine="_unique_debug_names" \
   -ba "${abs_srcdir}"/data/SPECS/hello-r2.spec
 
 rpm2cpio ${abs_builddir}/testing/build/RPMS/*/hello-1.0-2.*.rpm \
   | cpio -diu --quiet
 
 # Extract the build-id from the main file
+test -f $hello_file || echo "No $hello_file"
 id2=$(file $hello_file | sed 's/.*, BuildID[.*]=\(.*\),.*/\1/')
 
 if test "$id1" == "$id2"; then echo "equal"; else echo "unequal $id1 $id2"; fi
-- 
2.9.3

